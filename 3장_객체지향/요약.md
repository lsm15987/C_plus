# 객체지향
## 클래스
- 객체를 만들어내기 위해 정의된 설계도, 틀
- 클래스 자체는 객체가 아님, 단지 객체를 만들어 내기위한 틀
- 멤버 변수와 멤버 함수를 선언
	### 클래스 작성
	- 선언부와 구현부로 나뉜다.
	- 선언부
		- class 키워드를 사용
		- 클래스를 선언만 하기에 멤버 변수 초기화 및 멤버 함수 구현 불가능
		- 멤버에 대한 접근 권한 지정
			- private, public, protected
			- 디폴트로 private
	- 구현부
		- 클래스에 정의된 모든 멤버 함수 구현
		- 선언과 구현을 분리함으로써 다른 파일에서도 클래스를 활용
## 객체
- 클래스의 모양을 그대로 가지고 탄생
- 객체 = 상태(state, 멤버 변수) + 행동(behavior, 멤버 함수)
- 메모리에 생성, 실체(instance)
- 같은 클래스에서 여러 개의 객체를 생성 가능하며, 각 객체는 별도의 공간에 생성
## 생성자
- 객체가 생성되는 시점에서 자동으로 호출되는 멤버 함수
- 클래스 이름과 동일한 멤버 함수이며, 리턴 타입이 없고, 매개 변수로 구분한다.
- 생성자의 목적
	- 객체가 생성될 때 객체에 대한 정보를 초기화 시키 위해
- 생성자는 중복이 가능하며, 객체 생성 시 오직 한 번만 호출된다.
- 생성자가 선언되어 있지 않으면 기본 생성자가 자동으로 생성된다.
	- 기본 생성자 -> Circle();
	- 생성자가 선언되면 기본생성자는 없음
	- 필요하다면 반드시 직접 선언해야함.
- 위임 생성자
	- 생성자가 다른 생성자 호출
	- 여러 생성자에 중복 작성된 코드의 간소화를 위해 사용됨
	- 타겟 생성자
		- 객체 초기화를 전담하는 생성자
	- 위임 생성자
		- 객체 초기화를 타겟 생성자에 위임
- 다양한 생성자의 멤버 변수 초기화 방법
	- 생성자 코드에서 멤버 변수 초기화
	- 생성자 서두에 초깃값으로 초기화
	```cpp
	Point::Point():x(0),y(0){ // 멤버 변수 x, y를 0으로 초기화 }
	```
	- 클래스 선언부에서 직접 초기화
	```cpp
	class Point{
		int x=0,y=0; // 클래스 선언부에서 x, y를 0으로 직접 초기화
	public:
	  ...
	}
	```
## 소멸자
- 객체가 소멸되는 시점에서 자동으로 호출되는 함수
- 오직 한번만 자동 호출, 임의로 호출할 수 없음
- 객체 메모리 소멸 직전 호출됨
	- main 함수가 종료되면 객체가 소멸
-  목적
	- 객체가 사라질 때 마무리 작업을 위함
- 클래스 생성자 앞에 ~ 를 붙인다
	- 예) Circle::~Circle(){}
- 소멸자는 리턴 타입이 없고, 어떤 값도 리턴하면 안됨
- 소멸자는 한 클래스 내에 오직 한 개만 작성 가능
- 기본 생성자와 같이, 기본 소멸자가 존재
### 생성자/소멸자 실행 순서
* 객체가 선언된 위치에 따른 분류
	* 지역 객체
		*  함수 내에 선언된 객체로서, 함수가 종료하면 소멸된다.
	* 전역 객체
		* 함수의 바깥에 선언된 객체로서, 프로그램이 종료할 때 소멸된다.
* 객체 생성 순서
	* 전역 객체는 프로그램에서 선언된 순서로 생성
	* 지역 객체는 함수가 호출되는 순간에 순서대로 생성
* 객체 소멸 순서
	* 함수가 종료하면, 지역 객체가 생성된 순서의 역순으로 소멸
	* 프로그램이 종료하면, 전역 객체가 생성된 순서의 역순으로 소멸
    * main도 엄연한 함수이기에 지역 객체보다 먼저 소멸
* new를 이용하여 동적으로 생성된 객체의 경우
	* new를 실행하는 순간 객체 생성
	* delete 연산자를 실행할 때 객체 소멸
## 캡슐화
- 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없게 한다.
- 객체 내 데이터에 대한 보안, 보호, 외부 접근 제한
- 객체의 일부분을 공개하여 외부와의 인터페이스 제공(정보 교환 및 통신)
- 목적
    - 객체 보호, 보안
    - 중요한 멤버는 다른 클래스나 객체에서 접근할 수 없도록 보호
    - 외부와의 인터페이스를 위해서 일부 멤버는 외부에 접근 허용
- 3가지 접근 지정자
    - private
        - 동일한 클래스의 멤버 함수에만 접근함
        - 디폴트 접근 지정자
    - public
        - 모든 다른 클래스에 허용
    - protected
        - 클래스 자신과 상속받은 자식 클래스에만 허용
## 인라인 함수
- 작은 크기의 함수를 호출하면?
	- 함수 실행 시간 < 호출을 위해 소요되는 부가적인 시간 오버헤드
	- 이를 해결 하기 위해 인라인 함수를 사용
- inline 키워드로 선언된 함수
- 인라인 함수를 호출하는 곳에 인라인 함수 코드를 확장 삽입
- 함수 호출에 따른 오버헤드가 존재하지 않는다.
- 컴팡이러에 의해 이루어진다.
- 제약 사항
	- inline은 컴파일러에게 주는 요구 메시지
	- recursion, 긴 함수, static 변수, 반복문, switch 문, goto 문 등을 가진 함수는 수용하지 않음.
- 자동 인라인 함수
	- 클래스 선언부에 구현된 멤버 함수
	- 컴파일러에 의해 자동으로 처리 되어 inline으로 선언할 필요 없음
	- 생성자를 포함, 모든 함수가 자동 인라인 함수 가능
## C++ 구조체
- C언어와의 호환성 때문에 구조체를 수용하였다.
- 상속, 멤버, 접근 지정 등 모든 것이 클래스와 동일
- 클래스와 유일하게 다른 점
	- 구조체의 디폴트 접근 지정 -> public 이라는 점
- 구조체 객체 생성
	- struct 키워드 생략
	- C 에서는 struct 키워드를 사용했지만 C++ 에서는 클래스 처럼 사용함
	- 클래스 vs 구조체
		- 상속(물론 다형성도 불가능)
		- reference type 과 value type
## 헤더 파일, cpp 파일
- 클래스의 재사용을 위해 클래스마다 헤더 파일과 cpp 파일로 분리하여 작성
- 클래스 선언부
	- 헤더 파일(,h)에 저장
- 클래스 구현부
	- cpp 파일에 저장
	- 클래스가 선언된 헤더 파일 include
- 정확히, 클래스 선언.h, 클래스 구현.cpp, main.cpp 로 구분한다.
- 헤더파일의 중복
	- 같은 헤더 파일을 중복 include 하는 것을 방지하기 위해 
	- #ifndef ~ #endif 를 사용한다.
	- 사이에 #define 을 넣어 처음 include 를 제외하고 나머지는 조건에 맞지 않도록 한다
	- (만약 정의 되어있지 않다면 실행)~(여기까지)
