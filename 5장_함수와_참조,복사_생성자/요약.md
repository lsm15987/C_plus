## 함수의 인자 전달 방식
### 값에 의한 호출(call by value)
- 함수가 호출되면 매개 변수가 스택에 생성됨
- 호출하는 코드에서 넘어온 값이 매개 변수에 복사됨
### 주소에 의한 호출(call by reference)
- 함수의 매개 변수는 포인터 타입
	- 함수가 호출되면 포인터 타입의 매개 변수가 스택에 생성됨
- 호출하는 코드에서 넘어온 주소 값이 매개 변수에 저장됨
#### 값에 의한 호출로 객체 전달
- 함수의 매개 변수 객체 생성
	- 매개 변수 객체의 공간이 스택에 할당
	- 호출하는 쪽의 객체가 매개 변수 객체에 그대로 복사됨
	- 매개변수 객체의 생성자는 호출되지 않음
	- 하지만 매개 변수 객체의 소멸자는 호출 된다.
#### 주소에 의한 호출로 객체 전달
- 함수 호출 시 객체의 주소만 전달
- 함수의 매개 변수는 객체에 대한 포인터 변수로 선언
- 함수 호출 시 생성자, 소멸자가 실행되지 않는 구조
## 객체 치환 및 객체 리턴
### 객체 치환
- 동일한 클래스 타입의 객체끼리 치환 가능
- 치환된 두 객체는 현재 내용물만 같을 뿐 독립적인 공간 유지
### 객체 리턴
- 함수의 리턴값을 객체로 할 수 있다.
## 참조 변수
- 이미 존재하는 변수에 대한 다른 이름을 선언
- 참조 변수에 새로운 공간을 할당하지 않는다.
- 초기화로 지정된 기존 변수를 공유한다.
- 포인터와 다른 점은 포인터는 주소를 가리키는 것
- 참조 변수는 진짜 대체자로 쓰이면, 포인터와 다르게 -> 를 사용하지 않는다.
- 가장 많이 활용하는 사례로 함수의 매개 변수를 참조 타입으로 선언한다.
## 참조 리턴
- C언어는 반드시 값만 리턴이 가능했다
- 하지만 C++은 값 외에 참조 리턴이 가능하다
- 단순히 생각하면 리턴하는 것의 참조 변수라고 생각하면 된다.
## 얕은 복사와 깊은 복사
### 얕은 복사
- 객체 복사 시, 객체의 멤버를 1:1로 복사
- 객체의 멤버 변수에 동적 메모리가 할당된 경우
	- 사본은 원본 객체가 할당 받은 메모리를 공유하는 문제 발생
### 깊은 복사
- 객체 복사 시, 객체의 멤버를 1:1로 복사
- 객체의 멤버 변수에 동적 메모리가 할당된 경우
	- 사본은 원본이 가진 메모리 크기 만큼 별도로 동적 할당
	- 원본의 동적 메모리에 있는 내용을 사본에 복사
	- 사본과 원본은 메모리를 공유하는 문제 x
### 복사 생성자(copy constructor)
- 객체의 복사 생성 시 호출되는 특별한 생성자
- 한 클래스에 오직 한 개만 선언 가능
- 생성자와 클래스 내에 중복 선언 가능
- 클래스에 대한 참조 매개 변수를 가지는 독특한 생성
	- Circle(const Circle &c);
#### 디폴트 복사 생성자
- 컴파일러는 자동으로 디폴트 복사 생성자 삽입
	- 원본 객체의 각 멤버를 사본에 복사한다.

